<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>üíó</title>
  <style>
    :root{
      --bg: #f2e6e1;            /* fondo beige */
      --ink: #2f2a28;
      --muted: rgba(47,42,40,.70);
      --accent: #c81e3a;
      --panelW: min(46vw, 560px);
      --treeW: min(48vw, 620px);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #000; /* para que el primer screen sea 100% negro */
      overflow:hidden;
    }

    /* escenas */
    .screen{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      overflow:hidden;
    }
    .screen.show{ display:flex; }

    /* ---------- 1) ROTATE SCREEN ---------- */
    #screenRotate{
      background:#000;
      color:#fff;
    }
    .rotateWrap{
      width:min(920px, 92vw);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:min(4vw, 48px);
      padding: 24px;
    }
    .phoneIcon{
      width: clamp(90px, 16vw, 150px);
      height: clamp(170px, 28vw, 280px);
      border: 6px solid #fff;
      border-radius: 28px;
      position:relative;
      transform-origin: 50% 65%;
      animation: phoneTilt 1.1s ease-in-out infinite alternate;
      opacity:.95;
    }
    .phoneIcon::before{
      content:"";
      position:absolute;
      left:18%;
      right:18%;
      top:10%;
      height:6px;
      background:#fff;
      border-radius:6px;
      opacity:.9;
    }
    .phoneIcon::after{
      content:"";
      position:absolute;
      inset:10px;
      border: 2px solid rgba(255,255,255,.25);
      border-radius: 22px;
    }
    @keyframes phoneTilt{
      from{ transform: rotate(-14deg); }
      to  { transform: rotate(14deg); }
    }
    .rotText{
      line-height:1.05;
    }
    .rotText .big{
      font-weight: 800;
      letter-spacing:.03em;
      font-size: clamp(22px, 4.2vw, 44px);
    }
    .rotText .small{
      margin-top: 12px;
      font-size: clamp(14px, 2.2vw, 20px);
      color: rgba(255,255,255,.78);
      font-weight: 600;
    }

    /* ---------- 2) HEART GATE SCREEN ---------- */
    #screenGate{
      background: var(--bg);
      color: var(--ink);
    }
    .gateWrap{
      width:min(1100px, 96vw);
      display:grid;
      grid-template-columns: auto 1fr;
      align-items:center;
      gap: min(4vw, 46px);
      padding: 28px 18px;
    }
    .heartBtn{
      width: clamp(78px, 10vw, 110px);
      height: clamp(78px, 10vw, 110px);
      display:grid;
      place-items:center;
      cursor:pointer;
      user-select:none;
      border:none;
      background: transparent;
      filter: drop-shadow(0 14px 18px rgba(0,0,0,.12));
      transform: translateZ(0);
      transition: transform .15s ease;
    }
    .heartBtn:active{ transform: scale(.95); }
    .heartSvg{
      width: 100%;
      height: 100%;
    }
    .gateText{
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .gateTitle{
      font-size: clamp(26px, 4.2vw, 52px);
      font-weight: 900;
      color: var(--accent);
      line-height:1.02;
    }
    .gateHint{
      font-size: clamp(14px, 2.1vw, 22px);
      font-weight: 700;
      color: rgba(0,0,0,.45);
    }

    /* ---------- 3) TREE SCREEN ---------- */
    #screenTree{
      background: var(--bg);
      color: var(--ink);
      padding: 0;
    }
    .treeLayout{
      width: min(1200px, 96vw);
      height: min(620px, 86vh);
      display:grid;
      grid-template-columns: var(--panelW) var(--treeW);
      gap: min(3vw, 42px);
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    @media (max-width: 860px){
      /* en pantallas peque√±as se acomoda pero mantiene orden izquierda/derecha */
      .treeLayout{
        grid-template-columns: 1fr 1fr;
        height: min(720px, 88vh);
      }
    }
    @media (max-width: 680px){
      /* si es muy angosto, apila pero sigue legible */
      .treeLayout{
        grid-template-columns: 1fr;
        height: 92vh;
      }
    }

    .letter{
      width:100%;
      max-height: 100%;
      overflow:hidden;
    }
    .typed{
      font-size: clamp(13px, 1.65vw, 18px);  /* m√°s peque√±o para que entre todo */
      line-height: 1.35;
      font-weight: 650;                      /* un poco m√°s fino (no tan grueso) */
      color: rgba(0,0,0,.72);
      white-space: pre-wrap;
    }

    .canvasWrap{
      width:100%;
      height:100%;
      position:relative;
      border-radius: 22px;
      overflow:hidden;
      background: radial-gradient(circle at 40% 35%, rgba(255,255,255,.55), rgba(255,255,255,0) 52%);
    }
    canvas{ width:100%; height:100%; display:block; }

    .fade{
      animation: fadeIn .35s ease both;
    }
    @keyframes fadeIn{ from{opacity:0} to{opacity:1} }

    /* peque√±o ‚Äúsuelo‚Äù extra (si el canvas no alcanza) */
    .groundLine{
      position:absolute;
      left: 10%;
      right: 8%;
      bottom: 13%;
      height: 3px;
      background: rgba(0,0,0,.28);
      border-radius: 3px;
      pointer-events:none;
    }
  </style>
</head>
<body>

  <!-- 1) pantalla negra -->
  <section id="screenRotate" class="screen show">
    <div class="rotateWrap">
      <div class="phoneIcon" aria-hidden="true"></div>
      <div class="rotText">
        <div class="big">–ü–û–ñ–ê–õ–£–ô–°–¢–ê,<br/>–ü–û–í–ï–†–ù–ò –¢–ï–õ–ï–§–û–ù</div>
        <div class="small">–°–µ–π—á–∞—Å –Ω–∞—á–Ω—ë—Ç—Å—è —Å—é—Ä–ø—Ä–∏–∑ ‚ú®</div>
      </div>
    </div>
  </section>

  <!-- 2) coraz√≥n -->
  <section id="screenGate" class="screen">
    <div class="gateWrap fade">
      <button class="heartBtn" id="heartStart" aria-label="–ù–∞–∂–º–∏ –Ω–∞ —Å–µ—Ä–¥–µ—á–∫–æ">
        <!-- coraz√≥n NO deforme -->
        <svg class="heartSvg" viewBox="0 0 64 64" role="img" aria-hidden="true">
          <path fill="#d81f3b" d="M32 56s-18.6-10.9-26.1-22C-2.8 21.1 6.2 6 20.4 10.4c5 1.6 8.1 6.2 11.6 10.6 3.5-4.4 6.6-9 11.6-10.6C57.8 6 66.8 21.1 58.1 34 50.6 45.1 32 56 32 56z"/>
          <path fill="rgba(255,255,255,.35)" d="M23 16c-4.7 0-8.6 3.9-8.6 8.6 0 1 .2 1.9.5 2.8.3-4 3.7-7.2 7.9-7.2 1.6 0 3 .4 4.2 1.2-1.2-2.2-2.7-5.4-4-5.4z"/>
        </svg>
      </button>

      <div class="gateText">
        <div class="gateTitle">–° –î–ù–Å–ú –°–í–Ø–¢–û–ì–û<br/>–í–ê–õ–ï–ù–¢–ò–ù–ê!</div>
        <div class="gateHint">–ù–∞–∂–º–∏ –Ω–∞ —Å–µ—Ä–¥–µ—á–∫–æ üíû</div>
      </div>
    </div>
  </section>

  <!-- 3) √°rbol -->
  <section id="screenTree" class="screen">
    <div class="treeLayout fade">
      <div class="letter">
        <div id="typed" class="typed"></div>
      </div>

      <div class="canvasWrap">
        <canvas id="cv"></canvas>
        <div class="groundLine"></div>
      </div>
    </div>
  </section>

<script>
(() => {
  const screenRotate = document.getElementById('screenRotate');
  const screenGate   = document.getElementById('screenGate');
  const screenTree   = document.getElementById('screenTree');
  const heartStart   = document.getElementById('heartStart');
  const typedEl      = document.getElementById('typed');
  const cv           = document.getElementById('cv');
  const ctx          = cv.getContext('2d');

  // --- 1) inicio 4s -> gate
  setTimeout(() => {
    screenRotate.classList.remove('show');
    screenGate.classList.add('show');
  }, 4000);

  // --- 2) click coraz√≥n -> √°rbol
  heartStart.addEventListener('click', () => {
    screenGate.classList.remove('show');
    screenTree.classList.add('show');
    startTreeScene();
  });

  // ----------- TREE SCENE (canvas) -----------
  let W=0, H=0, dpr=1;

  function resize(){
    const r = cv.getBoundingClientRect();
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(r.width  * dpr);
    H = Math.floor(r.height * dpr);
    cv.width = W; cv.height = H;
  }

  window.addEventListener('resize', resize);

  // Mensaje (RUSO). Se escribe palabra por palabra.
  const messageWords = (
`–ò–Ω–æ–≥–¥–∞ –º–Ω–µ –∫–∞–∂–µ—Ç—Å—è, —á—Ç–æ –º–∏—Ä —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Ç–µ–ø–ª–µ–µ, –∫–æ–≥–¥–∞ —è –¥—É–º–∞—é –æ —Ç–µ–±–µ.

–¢—ã —É–º–µ–µ—à—å –¥–µ–ª–∞—Ç—å –æ–±—ã—á–Ω—ã–π –¥–µ–Ω—å –æ—Å–æ–±–µ–Ω–Ω—ã–º ‚Äî –ø—Ä–æ—Å—Ç–æ —Å–≤–æ–∏–º –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏–µ–º.

–ú–Ω–µ —Ö–æ—á–µ—Ç—Å—è –±–µ—Ä–µ—á—å —Ç–µ–±—è, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –∏ —Ä–∞–¥–æ–≤–∞—Ç—å, –¥–∞–∂–µ –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏.

–Ø —Ü–µ–Ω—é –∫–∞–∂–¥—É—é –Ω–∞—à—É –º–∏–Ω—É—Ç—É, –∫–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ –∏ –∫–∞–∂–¥—É—é —É–ª—ã–±–∫—É.

–Ø –æ—á–µ–Ω—å —Å–∫—É—á–∞—é‚Ä¶ –∏ –ø—Ä–∞–≤–¥–∞, –æ—á–µ–Ω—å —Ç–µ–±—è –ª—é–±–ª—é.`).split(/\s+/);

  // Animaci√≥n estados
  let t0=0;
  let phase = 0; // 0=tronco/ramas, 1=hojas, 2=typing
  let trunkProg=0;     // 0..1
  let leavesProg=0;    // 0..1
  let typingIndex=0;
  let lastWordAt=0;

  // Part√≠culas de hojas (est√°ticas) + viento (cayendo)
  let leafDots = [];
  let windHearts = [];

  function startTreeScene(){
    resize();
    // posici√≥n del √°rbol: a la derecha pero no pegado
    buildLeafDots();
    phase = 0;
    trunkProg = 0;
    leavesProg = 0;
    typingIndex = 0;
    typedEl.textContent = "";
    lastWordAt = performance.now();
    t0 = performance.now();
    requestAnimationFrame(tick);
  }

  function rand(a,b){ return a + Math.random()*(b-a); }

  function heartPoint(u){
    // forma de coraz√≥n cl√°sica (param√©trica)
    // u: 0..2pi
    const x = 16*Math.pow(Math.sin(u),3);
    const y = 13*Math.cos(u)-5*Math.cos(2*u)-2*Math.cos(3*u)-Math.cos(4*u);
    return {x, y};
  }

  function buildLeafDots(){
    leafDots.length = 0;

    // Centro copa (derecha), y tama√±o (para que sea coraz√≥n grande)
    const cx = W * 0.68;
    const cy = H * 0.36;
    const scale = Math.min(W,H) * 0.022; // controla tama√±o del coraz√≥n

    // MUCHAS hojas pero sin exagerar (95% aprox)
    const N = 430; // densidad ajustada

    // relleno dentro del coraz√≥n: muestreo por rechazo
    // bounding box aproximado del coraz√≥n param√©trico
    for(let i=0; i<N; i++){
      // punto random dentro de caja y comprobar si est√° dentro del coraz√≥n (aprox)
      let px, py, tries=0;
      while(tries++ < 40){
        px = rand(-16, 16);
        py = rand(-17, 13);
        // condici√≥n simple para "interior" (aprox): usar f√≥rmula impl√≠cita del coraz√≥n
        // (x^2 + y^2 - 1)^3 - x^2 y^3 <= 0
        const x = px/18;
        const y = py/18;
        const f = Math.pow(x*x + y*y - 1, 3) - (x*x)*(y*y*y);
        if(f <= 0) break;
      }

      const X = cx + px*scale*1.35;
      const Y = cy - py*scale*1.35;

      // colores tipo ‚Äúhojas-coraz√≥n‚Äù
      const shades = ["#ff2b68","#ff4f7d","#ff6a8f","#ff86a3","#ff9bb0"];
      leafDots.push({
        x:X, y:Y,
        r: rand(6, 10) * dpr,
        a: rand(0.70, 0.98),
        c: shades[(Math.random()*shades.length)|0],
        rot: rand(-1.2, 1.2)
      });
    }
  }

  function drawHeartLeaf(x,y,r,rot,color,alpha){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;

    // coraz√≥n peque√±o con bezier
    const s = r;
    ctx.beginPath();
    ctx.moveTo(0, s*0.35);
    ctx.bezierCurveTo(0, -s*0.15, -s*0.75, -s*0.15, -s*0.75, s*0.35);
    ctx.bezierCurveTo(-s*0.75, s*0.75, -s*0.35, s*1.05, 0, s*1.25);
    ctx.bezierCurveTo(s*0.35, s*1.05, s*0.75, s*0.75, s*0.75, s*0.35);
    ctx.bezierCurveTo(s*0.75, -s*0.15, 0, -s*0.15, 0, s*0.35);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  function drawTrunkAndBranches(p){
    // p 0..1
    // tronco (visible solo abajo; arriba lo tapar√°n hojas)
    const baseX = W * 0.68;
    const baseY = H * 0.80;

    // base ancha
    const trunkH = H * 0.48;
    const topY   = baseY - trunkH;

    // ancho: m√°s ancho abajo, m√°s delgado arriba
    const wBottom = 32 * dpr;
    const wTop    = 16 * dpr;

    // ‚Äúsuelo‚Äù (l√≠nea)
    ctx.lineWidth = 3 * dpr;
    ctx.strokeStyle = "rgba(0,0,0,.28)";
    ctx.beginPath();
    ctx.moveTo(W*0.18, baseY + 10*dpr);
    ctx.lineTo(W*0.92, baseY + 10*dpr);
    ctx.stroke();

    // tronco
    ctx.fillStyle = "#2b211f";
    ctx.globalAlpha = 1;

    const progY = topY + (1-p) * trunkH; // sube al dibujarse

    // dibujar solo hasta cierto avance
    ctx.beginPath();
    ctx.moveTo(baseX - wBottom, baseY);
    ctx.lineTo(baseX + wBottom, baseY);
    ctx.lineTo(baseX + wTop,   Math.min(progY, baseY));
    ctx.lineTo(baseX - wTop,   Math.min(progY, baseY));
    ctx.closePath();
    ctx.fill();

    // rama base curvada (soporte abajo)
    ctx.strokeStyle = "#2b211f";
    ctx.lineCap = "round";
    ctx.lineWidth = 10 * dpr;
    ctx.beginPath();
    ctx.moveTo(baseX - 28*dpr, baseY + 10*dpr);
    ctx.quadraticCurveTo(baseX, baseY + 30*dpr, baseX + 28*dpr, baseY + 10*dpr);
    ctx.stroke();

    // ramas (se van dibujando con p)
    const bp = Math.max(0, Math.min(1, (p - 0.35) / 0.65));

    ctx.lineWidth = 12 * dpr;
    ctx.beginPath();
    ctx.moveTo(baseX, topY + 42*dpr);
    ctx.quadraticCurveTo(baseX - 30*dpr, topY + 18*dpr, baseX - 90*dpr*bp, topY - 20*dpr*bp);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(baseX, topY + 45*dpr);
    ctx.quadraticCurveTo(baseX + 30*dpr, topY + 18*dpr, baseX + 90*dpr*bp, topY - 20*dpr*bp);
    ctx.stroke();

    // ramitas internas (se ver√°n poco porque hojas las tapar√°n)
    ctx.lineWidth = 8 * dpr;
    ctx.globalAlpha = 0.85;
    ctx.beginPath();
    ctx.moveTo(baseX - 10*dpr, topY + 35*dpr);
    ctx.quadraticCurveTo(baseX - 35*dpr, topY + 20*dpr, baseX - 55*dpr*bp, topY + 5*dpr*bp);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(baseX + 10*dpr, topY + 35*dpr);
    ctx.quadraticCurveTo(baseX + 35*dpr, topY + 20*dpr, baseX + 55*dpr*bp, topY + 5*dpr*bp);
    ctx.stroke();

    ctx.globalAlpha = 1;
  }

  function spawnWindHeart(){
    // corazones ‚Äúviento‚Äù
    const startX = rand(W*0.45, W*0.95);
    const startY = rand(-40*dpr, H*0.10);
    const shades = ["#ff2b68","#ff4f7d","#ff6a8f","#ff86a3","#ff9bb0"];
    windHearts.push({
      x:startX, y:startY,
      vx: rand(-0.9, -0.2)*dpr,   // se van a la izquierda (viento)
      vy: rand(0.8, 1.8)*dpr,     // caen
      r: rand(5, 9)*dpr,
      rot: rand(-1, 1),
      vr: rand(-0.03, 0.03),
      a: rand(0.35, 0.75),
      c: shades[(Math.random()*shades.length)|0],
    });
    if(windHearts.length > 130) windHearts.shift();
  }

  function drawLeaves(p){
    // p 0..1: aparece gradualmente
    const count = Math.floor(leafDots.length * p);
    for(let i=0; i<count; i++){
      const L = leafDots[i];
      drawHeartLeaf(L.x, L.y, L.r, L.rot, L.c, L.a);
    }

    // capa extra para ‚Äútapar ramas y tronco arriba‚Äù
    // (esto hace que casi no se vean ramas)
    ctx.save();
    ctx.globalAlpha = Math.min(1, p) * 0.9;
    ctx.fillStyle = "rgba(242,230,225,.55)";
    ctx.beginPath();
    ctx.arc(W*0.68, H*0.44, Math.min(W,H)*0.12, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function updateTyping(now){
    // palabra por palabra
    const speedMs = 110; // velocidad
    if(typingIndex >= messageWords.length) return;

    if(now - lastWordAt >= speedMs){
      const w = messageWords[typingIndex++];
      typedEl.textContent += (typedEl.textContent ? " " : "") + w;
      lastWordAt = now;
    }
  }

  function tick(now){
    ctx.clearRect(0,0,W,H);

    // fondo suave
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() || "#f2e6e1";
    ctx.fillRect(0,0,W,H);

    // fases
    if(phase === 0){
      trunkProg = Math.min(1, trunkProg + 0.018);
      drawTrunkAndBranches(trunkProg);

      if(trunkProg >= 1){
        phase = 1;
      }
    } else if(phase === 1){
      drawTrunkAndBranches(1);
      leavesProg = Math.min(1, leavesProg + 0.020);
      drawLeaves(leavesProg);

      // viento empieza ya
      if(Math.random() < 0.35) spawnWindHeart();

      if(leavesProg >= 1){
        phase = 2;
        lastWordAt = now + 250; // pausa peque√±a
      }
    } else {
      drawTrunkAndBranches(1);
      drawLeaves(1);

      // viento continuo
      if(Math.random() < 0.42) spawnWindHeart();

      // actualizar viento
      for(const h of windHearts){
        h.x += h.vx;
        h.y += h.vy;
        h.rot += h.vr;
        // leve oscilaci√≥n
        h.x += Math.sin((now*0.002) + h.y*0.01) * 0.12*dpr;
        drawHeartLeaf(h.x, h.y, h.r, h.rot, h.c, h.a);
      }
      // limpiar fuera
      windHearts = windHearts.filter(h => h.y < H + 60*dpr && h.x > -80*dpr);

      // typing
      updateTyping(now);
    }

    requestAnimationFrame(tick);
  }
})();
</script>
</body>
</html>