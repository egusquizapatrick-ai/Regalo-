<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>üíó</title>
  <style>
    :root{
      --bg: #f0e0d8;
      --ink:#2b2b2b;
      --muted: rgba(59,43,43,.72);
      --heart:#e24b6a;
      --heart2:#ff6f8a;
      --panelW: min(44vw, 560px);
      --treeW: min(46vw, 620px);
      --safeL: max(16px, env(safe-area-inset-left));
      --safeR: max(16px, env(safe-area-inset-right));
      --safeT: max(14px, env(safe-area-inset-top));
      --safeB: max(14px, env(safe-area-inset-bottom));
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      overflow:hidden;
    }

    /* ====== SCREENS ====== */
    .screen{
      position:fixed; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: var(--safeT) var(--safeR) var(--safeB) var(--safeL);
    }
    .hidden{display:none !important;}

    /* ====== INTRO (BLACK) ====== */
    #intro{
      background:#000;
      color:#fff;
    }
    .introWrap{
      width:min(920px, 92vw);
      display:flex;
      align-items:center;
      justify-content:center;
      gap: clamp(16px, 4vw, 44px);
    }
    .phoneIcon{
      width: clamp(86px, 12vw, 140px);   /* m√°s peque√±o */
      aspect-ratio: 1/2.2;
      border: 4px solid #fff;
      border-radius: 34px;
      position:relative;
      opacity:.95;
      transform: rotate(-12deg);
      flex: 0 0 auto;
    }
    .phoneIcon:before{
      content:"";
      position:absolute;
      left:16%; right:16%;
      top:10%;
      height:10px;
      border-radius:999px;
      background:#fff;
      opacity:.35;
    }
    .introText{
      line-height:1.1;
      text-align:left;
      max-width: 560px;
    }
    .introText h1{
      margin:0 0 10px;
      font-size: clamp(22px, 4.2vw, 44px);
      letter-spacing:.02em;
      text-transform:uppercase;
      font-weight: 800;
    }
    .introText p{
      margin:0;
      font-size: clamp(14px, 2.1vw, 18px);
      opacity:.9;
      font-weight: 600;
    }

    /* ====== HEART START SCREEN (optional click) ====== */
    #start{
      background: var(--bg);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .startWrap{
      width:min(980px, 92vw);
      display:flex;
      align-items:center;
      justify-content:center;
      gap: clamp(18px, 4vw, 56px);
    }
    .bigHeartBtn{
      appearance:none;
      border:0;
      background:transparent;
      cursor:pointer;
      display:grid;
      place-items:center;
      padding:0;
    }
    .bigHeart{
      width: clamp(92px, 14vw, 150px);
      aspect-ratio: 1/1;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.12));
      transition: transform .12s ease;
    }
    .bigHeartBtn:active .bigHeart{ transform: scale(.96); }
    .startText{
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .startTitle{
      margin:0;
      color:#c1253f;
      font-weight:900;
      font-size: clamp(22px, 4.4vw, 52px);
      line-height:1.02;
    }
    .startHint{
      margin:0;
      color:#b14a5b;
      font-weight:700;
      font-size: clamp(13px, 2vw, 18px);
      opacity:.95;
    }

    /* ====== MAIN (HORIZONTAL) ====== */
    #main{
      background: radial-gradient(1200px 700px at 70% 40%, rgba(255,255,255,.35), rgba(255,255,255,0)) , var(--bg);
      align-items:stretch;
      justify-content:center;
    }
    .mainWrap{
      width: min(1180px, 96vw);
      height: min(560px, 92vh);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: clamp(18px, 3vw, 44px);
      padding: clamp(14px, 2.5vw, 28px);
    }

    /* text left */
    .letter{
      width: var(--panelW);
      max-width: 620px;
      line-height:1.35;
      font-size: clamp(12.5px, 1.45vw, 17px); /* m√°s peque√±a para que entre completa */
      color: rgba(43,43,43,.88);
      font-weight: 600;
    }
    .letter p{
      margin:0;
    }
    .type{
      white-space: pre-wrap;
    }

    /* tree right */
    .treeArea{
      width: var(--treeW);
      display:flex;
      justify-content:center;
      align-items:center;
      position:relative;
    }
    canvas{
      width: 100%;
      max-width: 620px;
      aspect-ratio: 1 / 1; /* evita deformaci√≥n */
      height: auto;
      display:block;
      touch-action: manipulation;
    }

    /* responsive: if very narrow, stack but keep ‚Äúhorizontal vibe‚Äù */
    @media (max-width: 760px){
      .mainWrap{ flex-direction:column; height: 92vh; justify-content:center;}
      .letter{ width: 92%; max-width:none; }
      .treeArea{ width: 92%; }
    }
  </style>
</head>
<body>

  <!-- INTRO (4s) -->
  <section id="intro" class="screen">
    <div class="introWrap">
      <div class="phoneIcon" aria-hidden="true"></div>
      <div class="introText">
        <h1>–ü–û–ñ–ê–õ–£–ô–°–¢–ê,<br/>–ü–û–í–ï–†–ù–ò –¢–ï–õ–ï–§–û–ù</h1>
        <p>–°–µ–π—á–∞—Å –Ω–∞—á–Ω—ë—Ç—Å—è —Å—é—Ä–ø—Ä–∏–∑ ‚ú®</p>
      </div>
    </div>
  </section>

  <!-- START: heart + –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ (horizontal, no deformed) -->
  <section id="start" class="screen hidden">
    <div class="startWrap">
      <button class="bigHeartBtn" id="heartBtn" aria-label="–ù–∞–∂–º–∏ –Ω–∞ —Å–µ—Ä–¥–µ—á–∫–æ">
        <!-- SVG heart (no deform) -->
        <svg class="bigHeart" viewBox="0 0 64 64" role="img" aria-hidden="true">
          <path fill="#d61f45" d="M32 56s-19-11.7-26.1-23C-1.6 21.1 6.1 8 19.5 10.1c5 0.8 9 4.6 12.5 9.1c3.5-4.5 7.5-8.3 12.5-9.1C57.9 8 65.6 21.1 58.1 33C51 44.3 32 56 32 56z"/>
          <path fill="rgba(255,255,255,.25)" d="M22 18c-4.6.7-8.6 4.3-9.7 9.4c-.2.9.4 1.7 1.3 1.9c.9.2 1.7-.4 1.9-1.3c.8-3.8 3.7-6.5 7.1-7c.9-.1 1.5-1 1.4-1.8c-.1-.9-1-1.5-2-1.2z"/>
        </svg>
      </button>

      <div class="startText">
        <h2 class="startTitle">–° –î–Ω—ë–º<br/>—Å–≤—è—Ç–æ–≥–æ –í–∞–ª–µ–Ω—Ç–∏–Ω–∞!</h2>
        <p class="startHint">–ù–∞–∂–º–∏ –Ω–∞ —Å–µ—Ä–¥–µ—á–∫–æ üíû</p>
      </div>
    </div>
  </section>

  <!-- MAIN horizontal: text left, tree right -->
  <section id="main" class="screen hidden">
    <div class="mainWrap">
      <div class="letter">
        <p class="type" id="typed"></p>
      </div>

      <div class="treeArea">
        <canvas id="c" width="900" height="900"></canvas>
      </div>
    </div>
  </section>

<script>
/* ===================== FLOW ===================== */
const intro = document.getElementById('intro');
const start = document.getElementById('start');
const main  = document.getElementById('main');
const heartBtn = document.getElementById('heartBtn');

const INTRO_MS = 4000; // 4s exacto

setTimeout(() => {
  intro.classList.add('hidden');
  start.classList.remove('hidden');
}, INTRO_MS);

heartBtn.addEventListener('click', () => {
  start.classList.add('hidden');
  main.classList.remove('hidden');
  bootMain();
}, {passive:true});

/* ===================== MAIN SCENE ===================== */
const messageRU =
`–ò–Ω–æ–≥–¥–∞ –º–Ω–µ –∫–∞–∂–µ—Ç—Å—è, —á—Ç–æ –º–∏—Ä —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Ç–µ–ø–ª–µ–µ, –∫–æ–≥–¥–∞ —è –¥—É–º–∞—é –æ —Ç–µ–±–µ.
–¢—ã —É–º–µ–µ—à—å –¥–µ–ª–∞—Ç—å –æ–±—ã—á–Ω—ã–π –¥–µ–Ω—å –æ—Å–æ–±–µ–Ω–Ω—ã–º ‚Äî –ø—Ä–æ—Å—Ç–æ —Å–≤–æ–∏–º –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏–µ–º.

–ú–Ω–µ —Ö–æ—á–µ—Ç—Å—è –±–µ—Ä–µ—á—å —Ç–µ–±—è, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –∏ —Ä–∞–¥–æ–≤–∞—Ç—å, –¥–∞–∂–µ –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏.
–Ø —Ü–µ–Ω—é –∫–∞–∂–¥—É—é –Ω–∞—à—É –º–∏–Ω—É—Ç—É, –∫–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ –∏ –∫–∞–∂–¥—É—é —É–ª—ã–±–∫—É.

–Ø –æ—á–µ–Ω—å —Å–∫—É—á–∞—é‚Ä¶ –∏ –ø—Ä–∞–≤–¥–∞, –æ—á–µ–Ω—å —Ç–µ–±—è –ª—é–±–ª—é.`;

let typingTimer = null;
function typeText(el, text, speed=22){
  el.textContent = "";
  let i = 0;
  const tick = () => {
    el.textContent += text[i++];
    if(i < text.length) typingTimer = setTimeout(tick, speed);
  };
  tick();
}

/* Canvas tree */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function dprResize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  // keep internal square resolution
  const cssW = canvas.getBoundingClientRect().width;
  const size = Math.round(cssW * dpr);
  canvas.width = size;
  canvas.height = size;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(1,1);
}
window.addEventListener('resize', () => { if(!main.classList.contains('hidden')) dprResize(); }, {passive:true});

function rand(a,b){ return a + Math.random()*(b-a); }

function drawBackground(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // soft vignette
  const g = ctx.createRadialGradient(canvas.width*0.52, canvas.height*0.45, canvas.width*0.08,
                                    canvas.width*0.52, canvas.height*0.45, canvas.width*0.60);
  g.addColorStop(0, "rgba(255,255,255,.28)");
  g.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

/* Build a simple trunk + branches but we will HIDE most of them with leaves */
function drawTrunk(progress){
  const w = canvas.width, h = canvas.height;
  const baseY = h*0.80;
  const trunkH = h*0.45 * progress;

  // trunk bottom slightly wider
  const trunkBottomW = w*0.10;
  const trunkTopW    = w*0.055;
  const x = w*0.52; // a little left already (as you asked)
  const y0 = baseY;
  const y1 = baseY - trunkH;

  ctx.save();
  ctx.fillStyle = "#2a2525";
  ctx.beginPath();
  ctx.moveTo(x - trunkBottomW/2, y0);
  ctx.lineTo(x + trunkBottomW/2, y0);
  ctx.lineTo(x + trunkTopW/2,    y1);
  ctx.lineTo(x - trunkTopW/2,    y1);
  ctx.closePath();
  ctx.fill();

  // small root curve
  ctx.lineWidth = Math.max(6, w*0.012);
  ctx.strokeStyle = "#2a2525";
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.arc(x, y0+ (w*0.01), w*0.075, Math.PI*1.05, Math.PI*1.95);
  ctx.stroke();
  ctx.restore();

  return {x,yTop:y1, baseY:y0};
}

function drawBranches(progress, trunk){
  const w = canvas.width, h = canvas.height;
  const x = trunk.x, y = trunk.yTop;

  ctx.save();
  ctx.strokeStyle = "rgba(42,37,37,.75)";
  ctx.lineCap = "round";
  ctx.lineWidth = Math.max(6, w*0.010);

  const p = progress;
  // 2 main branches
  const leftEnd  = {x: x - w*0.18*p, y: y - h*0.10*p};
  const rightEnd = {x: x + w*0.20*p, y: y - h*0.12*p};

  ctx.beginPath();
  ctx.moveTo(x, y + h*0.01);
  ctx.quadraticCurveTo(x - w*0.02, y - h*0.02, leftEnd.x, leftEnd.y);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x, y + h*0.01);
  ctx.quadraticCurveTo(x + w*0.03, y - h*0.03, rightEnd.x, rightEnd.y);
  ctx.stroke();

  ctx.restore();

  return {leftEnd,rightEnd};
}

/* Heart canopy points (forms a heart shape) */
function heartPoint(t){
  // classic heart parametric (scaled later)
  const x = 16*Math.pow(Math.sin(t),3);
  const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
  return {x, y};
}

let leaves = [];
let petals = [];
let windT = 0;
let animStart = 0;
let running = false;

function buildLeaves(){
  leaves = [];
  const w = canvas.width, h = canvas.height;

  const cx = w*0.52;        // canopy center (tree slightly left inside canvas)
  const cy = h*0.34;
  const scale = Math.min(w,h) * 0.015;

  // density: many leaves but not insane
  const N = 520; // "m√°s hojas"
  for(let i=0;i<N;i++){
    const t = rand(0, Math.PI*2);
    const hp = heartPoint(t);
    // randomize inside heart: shrink factor r^k
    const r = Math.pow(Math.random(), 0.55);
    const x = cx + hp.x * scale * r * 2.1;
    const y = cy - hp.y * scale * r * 2.1;

    // size and color variety
    const size = rand(6, 15) * (canvas.width/900);
    const color = (Math.random()<0.5) ? "rgba(226,75,106,.78)" : "rgba(255,111,138,.72)";
    leaves.push({
      x,y,
      size,
      rot: rand(-Math.PI, Math.PI),
      wob: rand(0, Math.PI*2),
      color,
      // for "cover branches": draw leaves over branch area too
    });
  }
}

function spawnPetal(){
  const w=canvas.width, h=canvas.height;
  // spawn from canopy region
  const x = rand(w*0.35, w*0.90);
  const y = rand(h*0.18, h*0.48);
  const s = rand(8, 16) * (w/900);
  petals.push({
    x,y,
    vx: rand(0.20, 0.85) * (w/900),
    vy: rand(0.35, 0.95) * (w/900),
    rot: rand(0, Math.PI*2),
    vr: rand(-0.03, 0.03),
    s,
    a: rand(0.55, 0.9)
  });
}

function drawHeartShape(x,y,s,rot,a,fill){
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(rot);
  ctx.globalAlpha = a;
  ctx.fillStyle = fill;
  ctx.beginPath();
  // small heart path
  const k = s/16;
  ctx.moveTo(0, 5*k);
  ctx.bezierCurveTo(0, -5*k, -12*k, -5*k, -12*k, 3*k);
  ctx.bezierCurveTo(-12*k, 12*k, 0, 15*k, 0, 20*k);
  ctx.bezierCurveTo(0, 15*k, 12*k, 12*k, 12*k, 3*k);
  ctx.bezierCurveTo(12*k, -5*k, 0, -5*k, 0, 5*k);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawLeaves(t, trunk){
  // wind makes subtle sway and some falling petals
  const w=canvas.width, h=canvas.height;

  // Cover trunk/branches: draw an extra dense layer around center so branches barely visible,
  // but keep a bit of trunk bottom visible by masking area lower.
  for(const L of leaves){
    const sway = Math.sin(t*0.002 + L.wob) * (w*0.0025);
    const swayY = Math.cos(t*0.0016 + L.wob) * (w*0.0015);

    // keep trunk bottom visible: if too low, skip some leaves
    if(L.y > h*0.60 && Math.random() < 0.78) continue;

    drawHeartShape(L.x + sway, L.y + swayY, L.size, L.rot + Math.sin(t*0.001 + L.wob)*0.25, 1, L.color);
  }

  // petals wind
  const wind = Math.sin(t*0.0012)*0.7 + Math.cos(t*0.0007)*0.35;
  windT += 0.02;

  // spawn rate
  if(petals.length < 90 && Math.random() < 0.55) spawnPetal();

  for(const p of petals){
    p.vx += wind*0.002*(w/900);
    p.x += p.vx*(w/900)*3.1;
    p.y += p.vy*(w/900)*3.0;
    p.rot += p.vr;
    p.a *= 0.996;

    drawHeartShape(p.x, p.y, p.s, p.rot, p.a, "rgba(255,111,138,.60)");
  }
  // remove offscreen
  petals = petals.filter(p => p.y < h*1.05 && p.x < w*1.25 && p.a > 0.05);
}

function bootMain(){
  if(running) return;
  running = true;
  dprResize();
  buildLeaves();
  petals = [];
  animStart = performance.now();

  // stage timings
  const T_TRUNK = 900;     // trunk draw
  const T_BRANCH = 850;    // branch draw
  const T_LEAVES = 1500;   // leaves fade-in
  const T_TYPE_DELAY = 800;

  const typed = document.getElementById('typed');
  if(typingTimer) clearTimeout(typingTimer);

  function frame(now){
    const t = now - animStart;

    drawBackground();

    // trunk progress
    const pTrunk = Math.min(1, t / T_TRUNK);
    const trunk = drawTrunk(pTrunk);

    // branches
    const pBr = Math.min(1, Math.max(0, (t - T_TRUNK) / T_BRANCH));
    drawBranches(pBr, trunk);

    // leaves appear (fade in) and cover branches/trunk
    const pLv = Math.min(1, Math.max(0, (t - (T_TRUNK+T_BRANCH)) / T_LEAVES));
    ctx.save();
    ctx.globalAlpha = 0.15 + 0.85*pLv;
    drawLeaves(now, trunk);
    ctx.restore();

    // start typing after scene is visible
    if(t > (T_TRUNK+T_BRANCH+T_TYPE_DELAY) && typed.textContent.length === 0){
      typeText(typed, messageRU, 18); // typing speed
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}
</script>
</body>
</html>
