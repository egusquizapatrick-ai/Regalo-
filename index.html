<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>üíò</title>
  <style>
    :root{
      --bg: #efe0d8;
      --ink:#2b2b2b;
      --muted: rgba(43,43,43,.70);
      --heart:#d91f2a;
      --panelW: min(52vw, 560px);
      --safeL: max(16px, env(safe-area-inset-left));
      --safeR: max(16px, env(safe-area-inset-right));
      --safeT: max(16px, env(safe-area-inset-top));
      --safeB: max(16px, env(safe-area-inset-bottom));
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0}
    body{
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: var(--bg);
      color: var(--ink);
      overflow:hidden;
    }

    /* Pantallas */
    .screen{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: var(--bg);
    }
    .screen.show{display:flex}

    /* 1) Pantalla negra "gira el tel√©fono" */
    #screenRotate{
      background:#000;
      color:#fff;
    }
    .rotateWrap{
      width:min(92vw,900px);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:28px;
      padding:24px;
    }
    .phoneIcon{
      width:120px; height:240px;
      border:4px solid #fff;
      border-radius:28px;
      position:relative;
      opacity:.95;
      transform-origin:center;
      animation: tilt 1.2s ease-in-out infinite alternate;
    }
    .phoneIcon:before{
      content:"";
      position:absolute;
      top:14px; left:50%;
      width:40px; height:6px;
      background:#fff;
      border-radius:99px;
      transform:translateX(-50%);
      opacity:.85;
    }
    .rotateText{
      line-height:1;
      font-weight:800;
      letter-spacing:.5px;
      text-transform:uppercase;
      font-size: clamp(22px, 4.2vw, 54px);
      text-align:left;
      white-space:nowrap;
    }
    .rotateSub{
      font-weight:600;
      opacity:.85;
      margin-top:14px;
      font-size: clamp(14px, 2vw, 20px);
      text-transform:none;
      letter-spacing:0;
    }
    @keyframes tilt{
      from{ transform: rotate(0deg); }
      to  { transform: rotate(90deg); }
    }

    /* 2) Pantalla coraz√≥n (horizontal, no deformado) */
    #screenHeart{
      background: var(--bg);
    }
    .heartStage{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: calc(var(--safeT) + 12px) var(--safeR) calc(var(--safeB) + 12px) var(--safeL);
    }
    .heartRow{
      width:min(1100px, 96vw);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:36px;
    }
    .bigTitle{
      font-size: clamp(28px, 4.6vw, 64px);
      font-weight:900;
      color: var(--heart);
      line-height:1.02;
      margin:0;
      white-space:nowrap;
    }
    .smallHint{
      margin:10px 0 0;
      font-size: clamp(14px, 2vw, 20px);
      color: var(--muted);
      font-weight:600;
    }

    /* Bot√≥n coraz√≥n (sin c√≠rculo rojo, sin dedo) */
    .heartBtn{
      width: clamp(90px, 10vw, 140px);
      height: clamp(90px, 10vw, 140px);
      border:none;
      background: transparent;
      cursor:pointer;
      display:grid;
      place-items:center;
      padding:0;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.12));
      transform-origin:center;
      animation: pulse 1.2s ease-in-out infinite;
    }
    .heartBtn:active{transform:scale(.98)}
    @keyframes pulse{
      0%,100%{transform:scale(1)}
      50%{transform:scale(1.06)}
    }
    .heartSvg{
      width:100%; height:100%;
      display:block;
    }

    /* 3) Pantalla √°rbol + texto */
    #screenTree{
      background: var(--bg);
    }
    .treeLayout{
      width:100%;
      height:100%;
      display:flex;
      align-items:stretch;
      justify-content:center;
      gap: 18px;
      padding: calc(var(--safeT) + 10px) var(--safeR) calc(var(--safeB) + 10px) var(--safeL);
    }

    /* Texto izquierda */
    .letter{
      width: var(--panelW);
      padding: 8px 6px;
      display:flex;
      align-items:flex-start;
      justify-content:flex-start;
    }
    .letter p{
      margin:0;
      font-weight:700;
      color: var(--ink);
      font-size: clamp(14px, 1.55vw, 18px); /* m√°s peque√±a para que alcance */
      line-height:1.35;
    }

    /* Lado derecho: canvas */
    .scene{
      flex:1;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      min-width: 280px;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    /* ‚Äúsuelo‚Äù (l√≠nea) */
    .groundLine{
      position:absolute;
      left:0; right:0;
      bottom: calc(var(--safeB) + 34px);
      height:2px;
      background: rgba(43,43,43,.55);
      opacity:.65;
      transform: translateY(0);
      pointer-events:none;
    }

    /* peque√±o fade */
    .fadeOut{
      animation: fadeOut .35s ease forwards;
    }
    @keyframes fadeOut{
      to{opacity:0}
    }
  </style>
</head>
<body>

  <!-- 1) Negro 4s -->
  <section id="screenRotate" class="screen show" aria-hidden="false">
    <div class="rotateWrap">
      <div class="phoneIcon" aria-hidden="true"></div>
      <div>
        <div class="rotateText">–ü–û–ñ–ê–õ–£–ô–°–¢–ê,<br>–ü–û–í–ï–†–ù–ò –¢–ï–õ–ï–§–û–ù</div>
        <div class="rotateSub">–°–µ–π—á–∞—Å –Ω–∞—á–Ω—ë—Ç—Å—è —Å—é—Ä–ø—Ä–∏–∑ ‚ú®</div>
      </div>
    </div>
  </section>

  <!-- 2) Coraz√≥n + feliz san valent√≠n (RU) -->
  <section id="screenHeart" class="screen" aria-hidden="true">
    <div class="heartStage">
      <div class="heartRow">
        <button id="startBtn" class="heartBtn" aria-label="–ù–∞–∂–º–∏">
          <!-- coraz√≥n bonito, sin deformarse -->
          <svg class="heartSvg" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">
            <defs>
              <radialGradient id="g" cx="35%" cy="30%" r="70%">
                <stop offset="0%" stop-color="#ff6b74"/>
                <stop offset="55%" stop-color="#d91f2a"/>
                <stop offset="100%" stop-color="#a10f18"/>
              </radialGradient>
            </defs>
            <path d="M100 170
                     C20 115, 20 55, 58 45
                     C78 39, 95 52, 100 65
                     C105 52, 122 39, 142 45
                     C180 55, 180 115, 100 170Z"
                  fill="url(#g)"/>
            <path d="M72 58 C78 48, 92 45, 98 56"
                  fill="none" stroke="rgba(255,255,255,.55)" stroke-width="10" stroke-linecap="round"/>
          </svg>
        </button>

        <div>
          <h1 class="bigTitle">–° –î–Ω—ë–º —Å–≤—è—Ç–æ–≥–æ<br>–í–∞–ª–µ–Ω—Ç–∏–Ω–∞!</h1>
          <div class="smallHint">–ù–∞–∂–º–∏ –Ω–∞ —Å–µ—Ä–¥–µ—á–∫–æ üíû</div>
        </div>
      </div>
    </div>
  </section>

  <!-- 3) √Årbol + texto (horizontal) -->
  <section id="screenTree" class="screen" aria-hidden="true">
    <div class="treeLayout">
      <div class="letter">
        <p id="typedText"></p>
      </div>

      <div class="scene">
        <div class="groundLine"></div>
        <canvas id="c"></canvas>
      </div>
    </div>
  </section>

<script>
(() => {
  // ---------- helpers ----------
  const $ = (id) => document.getElementById(id);
  const screenRotate = $("screenRotate");
  const screenHeart  = $("screenHeart");
  const screenTree   = $("screenTree");
  const startBtn     = $("startBtn");
  const typedEl      = $("typedText");
  const canvas       = $("c");
  const ctx          = canvas.getContext("2d");

  function show(el){
    [screenRotate, screenHeart, screenTree].forEach(s => s.classList.remove("show"));
    el.classList.add("show");
  }

  // ---------- 1) negro 4s -> coraz√≥n ----------
  setTimeout(() => {
    show(screenHeart);
  }, 4000);

  // ---------- 2) click coraz√≥n -> √°rbol ----------
  startBtn.addEventListener("click", () => {
    show(screenTree);
    startTreeScene();
  });

  // ---------- texto ruso (typing) ----------
  const LETTER =
`–ò–Ω–æ–≥–¥–∞ –º–Ω–µ –∫–∞–∂–µ—Ç—Å—è, —á—Ç–æ –º–∏—Ä —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Ç–µ–ø–ª–µ–µ, –∫–æ–≥–¥–∞ —è –¥—É–º–∞—é –æ —Ç–µ–±–µ.
–¢—ã —É–º–µ–µ—à—å –¥–µ–ª–∞—Ç—å –æ–±—ã—á–Ω—ã–π –¥–µ–Ω—å –æ—Å–æ–±–µ–Ω–Ω—ã–º ‚Äî –ø—Ä–æ—Å—Ç–æ —Å–≤–æ–∏–º –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏–µ–º.
–Ø —Ö–æ—á—É –±–µ—Ä–µ—á—å —Ç–µ–±—è, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –∏ —Ä–∞–¥–æ–≤–∞—Ç—å, –¥–∞–∂–µ –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏.
–Ø —Ü–µ–Ω—é –∫–∞–∂–¥—É—é –Ω–∞—à—É –º–∏–Ω—É—Ç—É, –∫–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ –∏ –∫–∞–∂–¥—É—é —É–ª—ã–±–∫—É.
–Ø –æ—á–µ–Ω—å —Å–∫—É—á–∞—é‚Ä¶ –∏ –ø—Ä–∞–≤–¥–∞, –æ—á–µ–Ω—å —Ç–µ–±—è –ª—é–±–ª—é.`;

  function typeText(text, speed=22){
    typedEl.textContent = "";
    let i = 0;
    const t = setInterval(() => {
      typedEl.textContent += text[i++] || "";
      if(i >= text.length) clearInterval(t);
    }, speed);
  }

  // ---------- canvas scene ----------
  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    W = Math.max(1, Math.floor(rect.width  * DPR));
    H = Math.max(1, Math.floor(rect.height * DPR));
    canvas.width = W;
    canvas.height = H;
  }
  window.addEventListener("resize", resize);

  // √Årbol posici√≥n (un poquito a la izquierda dentro del lado derecho)
  function treeBaseX(){ return W * 0.55; }   // m√°s a la izquierda que antes
  function treeBaseY(){ return H * 0.78; }   // cerca del suelo

  // Ramas (solo para animaci√≥n inicial)
  function buildBranches(){
    const bx = treeBaseX(), by = treeBaseY();
    const trunkH = H * 0.42;
    const topY = by - trunkH;
    return [
      // tronco principal
      {x1:bx, y1:by, x2:bx, y2:topY, w1:18, w2:26, t:0},
      // ramas
      {x1:bx, y1:topY+30, x2:bx+W*0.10, y2:topY+H*0.08, w1:16, w2:8, t:0},
      {x1:bx, y1:topY+45, x2:bx-W*0.10, y2:topY+H*0.10, w1:14, w2:7, t:0},
      {x1:bx, y1:topY+65, x2:bx+W*0.14, y2:topY+H*0.16, w1:12, w2:6, t:0},
      {x1:bx, y1:topY+70, x2:bx-W*0.14, y2:topY+H*0.18, w1:12, w2:6, t:0},
    ];
  }

  // Hojas en forma coraz√≥n en una nube con forma de coraz√≥n
  function heartPoint(u,v){
    // f√≥rmula coraz√≥n (param√©trica) en [-1,1]
    // devolvemos un punto "nube" en forma de coraz√≥n
    // u: [0,1], v:[0,1] para dispersi√≥n
    const a = (u*2-1);
    const b = (v*2-1);
    // "distancia" al borde aproximada:
    // x^2 + (y - |x|^(2/3))^2 <= 1
    const x = a;
    const y = b;
    const inside = (x*x + Math.pow(y - Math.pow(Math.abs(x), 2/3), 2)) <= 1;
    return {x, y, inside};
  }

  function makeLeaves(count){
    const leaves = [];
    const bx = treeBaseX();
    const by = treeBaseY();
    const trunkH = H * 0.42;
    const topY = by - trunkH;

    // centro de copa (un poco arriba del top)
    const cx = bx;
    const cy = topY + H*0.10;

    // tama√±o de la copa
    const rx = W*0.18;
    const ry = H*0.24;

    // generamos puntos dentro de forma coraz√≥n (m√°s hojas, pero controladas)
    let tries = 0;
    while(leaves.length < count && tries < count*20){
      tries++;
      const u = Math.random();
      const v = Math.random();
      const p = heartPoint(u,v);
      if(!p.inside) continue;

      // mapear a tama√±o copa
      const px = cx + p.x * rx * 0.95;
      const py = cy + p.y * ry * 0.95;

      // tama√±o/tono
      const s = (Math.random()*0.8 + 0.7) * (H*0.018);
      const hue = 345 + Math.random()*10; // rosa/rojo
      const alpha = 0.85;

      leaves.push({
        x:px, y:py,
        s,
        rot: (Math.random()*Math.PI*2),
        a: alpha,
        h: hue
      });
    }
    return leaves;
  }

  // Part√≠culas de viento (corazoncitos cayendo)
  function makeBlownHearts(n){
    const arr = [];
    for(let i=0;i<n;i++){
      arr.push(newFallingHeart(true));
    }
    return arr;
  }
  function newFallingHeart(fromTop=false){
    const x = treeBaseX() + (Math.random()*W*0.35 - W*0.20);
    const y = fromTop ? (Math.random()*H*0.25) : (Math.random()*H);
    const s = (Math.random()*0.65 + 0.55) * (H*0.016);
    return {
      x, y, s,
      vx: (Math.random()*0.6 + 0.6) * (DPR*0.55),  // viento hacia derecha
      vy: (Math.random()*0.9 + 0.7) * (DPR*0.75),  // cae
      wob: Math.random()*Math.PI*2,
      rot: Math.random()*Math.PI*2,
      life: 0,
      tint: Math.random() < 0.55 ? "rgba(255,105,135,.75)" : "rgba(217,31,42,.75)"
    };
  }

  function drawHeart(x,y,size,rot,color){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    ctx.scale(size/30, size/30);
    ctx.beginPath();
    // coraz√≥n simple
    ctx.moveTo(0, 9);
    ctx.bezierCurveTo(-18, -5, -12, -22, 0, -12);
    ctx.bezierCurveTo(12, -22, 18, -5, 0, 9);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    ctx.restore();
  }

  function drawBranch(seg){
    const {x1,y1,x2,y2,w1,w2,t} = seg;
    const px = x1 + (x2-x1)*t;
    const py = y1 + (y2-y1)*t;

    // tronco/ramas color
    ctx.strokeStyle = "#2a1f1c";
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    // grosor interpolado
    const w = w1 + (w2-w1)*t;
    ctx.lineWidth = w;

    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(px,py);
    ctx.stroke();

    // base ancha del tronco (solo cuando es el tronco principal y ya casi termin√≥)
    if(seg === segments[0] && t > 0.85){
      const baseW = 48 * DPR; // base m√°s ancha
      ctx.lineWidth = 10*DPR;
      ctx.beginPath();
      ctx.moveTo(x1 - baseW*0.55, y1 + 6*DPR);
      ctx.quadraticCurveTo(x1, y1 + 22*DPR, x1 + baseW*0.55, y1 + 6*DPR);
      ctx.stroke();
    }
  }

  function drawLeaves(alphaMul=1){
    // hojas forman coraz√≥n; adem√°s cubren ramas/parte alta del tronco
    for(const L of leaves){
      const c = `hsla(${L.h}, 85%, 60%, ${L.a*alphaMul})`;
      drawHeart(L.x, L.y, L.s, L.rot, c);
    }
  }

  // Cubierta extra para "tapar" ramas (m√°s denso arriba, pero no excesivo)
  function drawLeafCover(){
    // duplicar algunas hojas con baja opacidad para ocultar ramas sin ‚Äúensuciar‚Äù
    for(let i=0;i<Math.floor(leaves.length*0.25);i++){
      const L = leaves[(i*7) % leaves.length];
      drawHeart(L.x + (Math.random()*10-5)*DPR, L.y + (Math.random()*10-5)*DPR,
                L.s*1.05, L.rot+0.2, "rgba(255,110,145,.55)");
    }
  }

  function drawFalling(){
    for(const p of blown){
      drawHeart(p.x, p.y, p.s, p.rot, p.tint);
    }
  }

  let segments = [];
  let leaves = [];
  let blown = [];
  let startTime = 0;
  let phase = "grow"; // grow -> leaves -> typing -> run
  let typingStarted = false;

  function startTreeScene(){
    resize();

    segments = buildBranches();
    // m√°s hojas (antes pediste tipo 95%, aqu√≠ lo hago ‚Äúcasi lleno‚Äù sin exagerar)
    leaves = makeLeaves(240); // sube/baja si quieres (220-280)
    blown  = makeBlownHearts(46);

    startTime = performance.now();
    phase = "grow";
    typingStarted = false;
    requestAnimationFrame(tick);
  }

  function tick(now){
    const t = (now - startTime);

    // limpiar
    ctx.clearRect(0,0,W,H);

    // fondo suave
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--bg").trim() || "#efe0d8";
    ctx.fillRect(0,0,W,H);

    // animaci√≥n tronco/ramas primero (r√°pido)
    if(phase === "grow"){
      const k = Math.min(1, t / 900); // 0.9s
      for(const s of segments){
        // cada segmento crece un poquito despu√©s
        const delay = (segments.indexOf(s))*110;
        const kk = Math.max(0, Math.min(1, (t - delay)/700));
        s.t = kk;
        drawBranch(s);
      }
      // cuando termina -> hojas
      if(k >= 1){
        phase = "leaves";
        startTime = now;
      }
    }

    // hojas aparecen (fade-in)
    if(phase === "leaves"){
      // a√∫n dibujamos tronco completo
      for(const s of segments){
        s.t = 1;
        drawBranch(s);
      }
      const a = Math.min(1, t / 900); // 0.9s
      drawLeaves(a);

      // capa extra para ocultar ramas y parte alta del tronco
      if(a > 0.55) drawLeafCover();

      // dejar visible solo la base: ‚Äútapa‚Äù del tronco superior con hojas ya lo hace
      // pasar a typing
      if(a >= 1){
        phase = "typing";
        startTime = now;
      }
    }

    // typing
    if(phase === "typing"){
      for(const s of segments){
        s.t = 1;
        drawBranch(s);
      }
      drawLeaves(1);
      drawLeafCover();

      if(!typingStarted){
        typingStarted = true;
        // comienza a escribir despu√©s de que hojas ya aparecieron
        setTimeout(() => typeText(LETTER, 20), 250);
      }
      // luego queda en run
      if(t > 1200){
        phase = "run";
        startTime = now;
      }
    }

    // run: viento + corazones cayendo
    if(phase === "run"){
      for(const s of segments){
        s.t = 1;
        drawBranch(s);
      }
      drawLeaves(1);
      drawLeafCover();

      // actualizar part√≠culas
      for(const p of blown){
        p.life += 1;
        p.wob += 0.06;
        p.x += p.vx + Math.sin(p.wob)*0.6*DPR;
        p.y += p.vy + Math.cos(p.wob*0.7)*0.35*DPR;
        p.rot += 0.02;

        // reciclar cuando sale
        if(p.y > H + 40*DPR || p.x > W + 60*DPR){
          Object.assign(p, newFallingHeart(true));
          p.y = -20*DPR;
        }
      }
      drawFalling();
    }

    requestAnimationFrame(tick);
  }
})();
</script>
</body>
</html>
